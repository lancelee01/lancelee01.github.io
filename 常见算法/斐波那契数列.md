## 一、概述
这个数列前两项为1，从第3项开始，每一项都等于前两项之和。

属于面试经常问的一个算法题，简单那是因为考虑的少，如果你跑一下程序，你就知道为什么你觉得简单了，下面进行分析及测试，以及为什么说不简单的原因。
## 二、编码及测试
### 1、常见的递归写法
``` markdown 
/**
 * 计算斐波那契数列项
 * @param i 第n项
 * @return 第n项对应结果
 */
private static Long fib(int i) {
    if(1 == i || 2 == i){
        return 1L;
    }
    return fib(i-1) + fib(i-2);
}
```
#### 测试结果【`机器为16G，4核`】：
19及以下：1ms  
20：2ms  
45：4900ms  
50：53000ms  11位结果
#### 存在问题：
（1）存储：long只能存储2^63-1，19位，只能算到92  
（2）效率：每次都要把之前的计算一次，呈指数级的增长
### 2、改进性能，使用缓存  
``` markdown
/** 记录计算好的斐波那契数列值 */
private static Map<Integer, Long> record = new HashMap<Integer, Long>();
/**
 * 计算斐波那契数列项
 * @param i 第n项
 * @return 第n项对应结果
 */
private static Long fibUseCache(int i) {
    if(1 == i || 2 == i){
	    return 1L;
    }
    Long result = record.get(i);
    if(null == result){
	    result = fibUseCache(i-1) + fibUseCache(i-2);
    }
    record.put(i, result);
    return result;
}
```
#### 测试结果【`机器为16G，4核`】
91及以下：1-2ms  4660046610375530309 19位结果
92：1/2ms 7540113804746346429 19位结果
#### 存在问题：
（1）存储，只能算到92
### 3、改变计算方式
``` markdown
/**
 * 计算斐波那契数列项
 * @param i 第n项
 * @return 第n项对应结果
 */
private static Long fibChangeArith(int i) {
    if(1 == i || 2 == i){
	    return 1L;
    }
    long a1 = 1;
    long a2 = 1;
    while(i-- > 1){
	    long temp = a1;
	    a1 = a1 + a2;
	    a2 = temp;
    }
    return a2;
}
```
#### 测试结果【`机器为16G，4核`】
92：约等于0ms 7540113804746346429 19位结果
#### 存在问题：
（1）存储，只能算到92
### 4、将